syntax = "proto3";

package messenger;

enum EncryptionAlgorithm {
  UNKNOWN_ALGORITHM = 0;
  LOKI97 = 1;
  TWOFISH = 2;
}

// Server -> Client messages
message ServerMessage {
  string message_id = 1; // Unique ID for each server message
  int64 timestamp = 2;   // Unix timestamp (seconds or millis)

  oneof event {
    RoomInfo room_info = 3;                // Sent on room creation/join success
    UserStatusUpdate user_status = 4;      // User joined/left
    ChatMessage chat_message = 5;          // Actual encrypted message
    KeyExchangeData key_exchange_data = 6; // For DH public keys
    ErrorNotification error = 7;
    RoomClosedNotification room_closed = 8;
    ServerAck server_ack = 9; // Generic acknowledgement
  }
}

message RoomInfo {
  string room_id = 1;
  EncryptionAlgorithm algorithm = 2;
  repeated string participants = 3; // client_ids in the room
}

message UserStatusUpdate {
  string room_id = 1;
  string client_id = 2;
  bool joined = 3; // true if joined, false if left
}

message ChatMessage {
  string room_id = 1; // Implicit from client's connection context or can be
  // explicit
  string sender_id = 2;
  bytes iv = 3;
  bytes encrypted_payload = 4; // Encrypted text or file chunk
  PayloadType payload_type = 5;
  string filename = 6;             // if payload_type is FILE or IMAGE
  bool is_last_chunk = 7;          // for file transfer
  int32 chunk_sequence_number = 8; // For ordering file chunks
  string unique_transfer_id = 9;   // ADD THIS to track all chunks of a file
}

enum PayloadType {
  TEXT = 0;
  FILE = 1;
  IMAGE = 2; // Could be a specific type of file
}

message KeyExchangeData {
  string room_id = 1; // Implicit
  string from_client_id = 2;
  string to_client_id = 3; // Target client for this DH key (server routes this)
  bytes public_key_dh = 4; // Diffie-Hellman public key
}

message ErrorNotification {
  // string room_id = 1; // Optional, if error is room-specific
  string message = 2;
  int32 error_code = 3; // Optional error code
}

message RoomClosedNotification {
  string room_id = 1;
  string reason = 2; // e.g., "Host closed the room", "Other user left"
}

message ServerAck {
  string original_request_id = 1; // ID of the client request being acked
  bool success = 2;
  string details = 3; // Optional details
}

// Client -> Server messages
message ClientRequest {
  string request_id = 1; // Unique ID for each client request
  string client_id =
      2; // Persistent client identifier (e.g., UUID generated by client)
  int64 timestamp = 3;

  oneof request {
    CreateRoomRequest create_room = 4;
    JoinRoomRequest join_room = 5;
    LeaveRoomRequest leave_room = 6;
    SendMessageRequest send_message = 7;
    SendKeyExchangeData send_key_exchange = 8;
    // CloseRoomRequest close_room = 9; // Or make LeaveRoomRequest handle this
    // for the last user
  }
}

message CreateRoomRequest {
  EncryptionAlgorithm algorithm = 1;
  // client_id is in the outer ClientRequest
}

message JoinRoomRequest {
  string room_id = 1;
  // client_id is in the outer ClientRequest
}

message LeaveRoomRequest {
  string room_id = 1;
  // client_id is in the outer ClientRequest
}

message SendMessageRequest {
  string room_id = 2;
  // sender_id is client_id from outer ClientRequest
  bytes iv = 3;
  bytes encrypted_payload = 4;
  PayloadType payload_type = 5;
  string filename = 6;
  bool is_last_chunk = 7;
  int32 chunk_sequence_number = 8;
  string unique_transfer_id = 9;
}

message SendKeyExchangeData {
  string room_id = 1;
  // from_client_id is client_id from outer ClientRequest
  // to_client_id is implicitly the other person in the room (server figures
  // this out)
  bytes public_key_dh = 2;
}

service MessengerService {
  // Bidirectional stream for all communication once a client connects.
  // The first message from client could be a "ConnectRequest" or implicitly
  // Create/Join.
  rpc ChatStream(stream ClientRequest) returns (stream ServerMessage);
}
